<!DOCTYPE html><html lang="ko"><head>
        <title>[TIL] JavaScript & TypeScript Essential - Chapter 4</title>
        <meta name="title" content="[TIL] JavaScript & TypeScript Essential - Chapter 4" />
        <meta name="description" content="Fastcampus의 김민태의 프론트엔드 아카데미 : 제 1 강 JavaScript & TypeScript Essential 강의 Chapter 4를 수강하며 기록한 내용입니다." />
        <meta name="keywords" content="Fastcampus,김민태의 프론트엔드 아카데미" />
        <meta property="og:url" content="https://yemsu.github.io/fastcampus-javascript-typescript-essential-2" />
        <meta property="og:type" content="article" />
        <meta property="og:title" content="[TIL] JavaScript & TypeScript Essential - Chapter 4" />
        <meta property="og:description" content="Fastcampus의 김민태의 프론트엔드 아카데미 : 제 1 강 JavaScript & TypeScript Essential 강의 Chapter 4를 수강하며 기록한 내용입니다." />
        <meta property="og:image" content="https://yemsu.github.io/images/og_image.jpg" />
        <meta property="twitter:card" content="https://yemsu.github.io/images/og_image.jpg" />
        <meta property="twitter:url" content="https://yemsu.github.io/fastcampus-javascript-typescript-essential-2" />
        <meta property="twitter:title" content="[TIL] JavaScript & TypeScript Essential - Chapter 4" />
        <meta property="twitter:description" content="Fastcampus의 김민태의 프론트엔드 아카데미 : 제 1 강 JavaScript & TypeScript Essential 강의 Chapter 4를 수강하며 기록한 내용입니다." />
        <meta property="twitter:image" content="https://yemsu.github.io/images/og_image.jpg" />
      <style>
    .utterances {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }
    .utterances-frame {
      color-scheme: light;
      position: absolute;
      left: 0;
      right: 0;
      width: 1px;
      min-width: 100%;
      max-width: 100%;
      height: 100%;
      border: 0;
    }
  </style><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2284%22>🌊</text></svg>"><title>ENJOY DEV</title><meta name="naver-site-verification" content="c702bde42c5742aa62750f39d810dd87c91f4811"><meta name="google-site-verification" content="rRA_cKc94OITZM0hBG9JQUQBl8IbTx9G7cY6mUo1hgw"><script src="https://partner.googleadservices.com/gampad/cookie.js?domain=localhost&amp;callback=_gfp_s_&amp;client=ca-pub-4052679554213032"></script><script src="https://pagead2.googlesyndication.com/pagead/managed/js/adsense/m202303300101/show_ads_impl.js" id="google_shimpl"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-922R4CGCRZ"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4052679554213032" crossorigin="anonymous" data-checked-head="true"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-922R4CGCRZ');</script><link href="/css/chunk-74d2d95d.css" rel="prefetch"><link href="/css/chunk-773fa2dd.css" rel="prefetch"><link href="/js/chunk-74d2d95d.js" rel="prefetch"><link href="/js/chunk-773fa2dd.js" rel="prefetch"><link href="/css/app.css" rel="preload" as="style"><link href="/js/app.js" rel="preload" as="script"><link href="/js/chunk-vendors.js" rel="preload" as="script"><link href="/css/app.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="/css/chunk-74d2d95d.css"><script charset="utf-8" src="/js/chunk-74d2d95d.js"></script><meta http-equiv="origin-trial" content="A0VQgOQvA+kwCj319NCwgf8+syUgEQ8/LLpB8RxxlRC3AkJ9xx8IAvVuQ/dcwy0ok7sGKufLLu6WhsXbQR9/UwwAAACFeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjg4MDgzMTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A6kRo9zXJhOvsR4D/VeZ9CiApPAxnOGzBkW88d8eIt9ex2oOzlX+AoUk/BS50Y9Ysy2jwyHR49Mb7XwP+l9yygIAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjg4MDgzMTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A3mbHZoS4VJtJ8j1aE8+Z9vaGf/oMV1eTNIWMrvGqWgNnOmvaxnRGliqKIZU2eiTzCj5Qpz8B1/UTTLuony5bAAAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjg4MDgzMTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="As0hBNJ8h++fNYlkq8cTye2qDLyom8NddByiVytXGGD0YVE+2CEuTCpqXMDxdhOMILKoaiaYifwEvCRlJ/9GcQ8AAAB8eyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiV2ViVmlld1hSZXF1ZXN0ZWRXaXRoRGVwcmVjYXRpb24iLCJleHBpcnkiOjE3MTk1MzI3OTksImlzU3ViZG9tYWluIjp0cnVlfQ=="><meta http-equiv="origin-trial" content="AgRYsXo24ypxC89CJanC+JgEmraCCBebKl8ZmG7Tj5oJNx0cmH0NtNRZs3NB5ubhpbX/bIt7l2zJOSyO64NGmwMAAACCeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiV2ViVmlld1hSZXF1ZXN0ZWRXaXRoRGVwcmVjYXRpb24iLCJleHBpcnkiOjE3MTk1MzI3OTksImlzU3ViZG9tYWluIjp0cnVlfQ=="><link rel="preload" href="https://adservice.google.co.kr/adsid/integrator.js?domain=localhost" as="script"><script type="text/javascript" src="https://adservice.google.co.kr/adsid/integrator.js?domain=localhost"></script><link rel="preload" href="https://adservice.google.com/adsid/integrator.js?domain=localhost" as="script"><script type="text/javascript" src="https://adservice.google.com/adsid/integrator.js?domain=localhost"></script></head><body><noscript><strong>We're sorry but ENJOY DEV doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app" data-v-app=""><metainfo></metainfo><header data-v-49c83e62=""><h1 data-v-49c83e62=""><a href="/" class="logo size-medium" data-v-295f0452="" data-v-49c83e62=""><span class="logo-text dev" data-v-295f0452=""> D<span class="hidden" data-v-295f0452="">E</span>V </span><span class="logo-text enjoy" data-v-295f0452=""><span class="common-e" data-v-295f0452="">E</span>NJOY🌊 </span></a></h1><div class="links" data-v-49c83e62=""><a href="https://github.com/yemsu/" title="Yemsu Github" target="_blank" data-v-49c83e62=""><svg aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="26" data-view-component="true" class="octicon octicon-mark-github v-align-middle"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></div></header><div class="container size-narrow" data-v-5006e508="" data-v-0cc18c81=""><nav class="outLiner" data-v-0cc18c81=""><h2 class="ir">글 목차 (클릭하여 바로가기)</h2><ul><li class=""><a href="#타입스크립트를-위한-환경-설정">타입스크립트를 위한 환경 설정</a></li><li class="title-sub"><a href="#📃-tsconfig.json">📃 tsconfig.json</a></li><li class=""><a href="#변수에-타입-작성하기">변수에 타입 작성하기</a></li><li class=""><a href="#함수의-규격-작성하기">함수의 규격 작성하기</a></li><li class="title-sub"><a href="#제네릭-관련-글">제네릭 관련 글</a></li><li class="title-sub"><a href="#vscode-extension-추천-:-REST-Client">vscode extension 추천 : REST Client</a></li><li class=""><a href="#타입과-인터페이스">타입과 인터페이스</a></li><li class="title-sub"><a href="#타입-알리아스">타입 알리아스</a></li><li class="title-sub"><a href="#인터페이스">인터페이스</a></li><li class=""><a href="#상속과-믹스인">상속과 믹스인</a></li><li class="title-sub"><a href="#믹스인">믹스인</a></li><li class="title-sub"><a href="#extends">extends</a></li><li class=""><a href="#View-class로-코드-구조-개선">View class로 코드 구조 개선</a></li><li class=""><a href="#파일의-분리,-더욱-성장할-앱을-위한-준비">파일의 분리, 더욱 성장할 앱을 위한 준비</a></li><li class=""><a href="#안전한-전역-상태-관리">안전한 전역 상태 관리</a></li><li class=""><a href="#XHR-to-Fetch-&amp;-Promise">XHR to Fetch &amp; Promise</a></li><li class=""><a href="#콜백-함수-없는-비동기-코드-작성법">콜백 함수 없는 비동기 코드 작성법</a></li><li class=""><a href="#후기">후기</a></li></ul></nav><!----><article data-v-0cc18c81="" style=""><div class="wrap-info" data-v-0cc18c81=""><h2 class="title" data-v-0cc18c81="">[TIL] JavaScript &amp; TypeScript Essential - Chapter 4</h2><p class="date" data-v-0cc18c81="">2023-2-3</p><ul class="keywords" data-v-0cc18c81=""><li class="keyword" data-v-0cc18c81="">Fastcampus</li><li class="keyword" data-v-0cc18c81="">김민태의 프론트엔드 아카데미</li></ul></div><div class="article" data-v-0cc18c81=""><p>드디어 4장 타입스크립트!</p>
<hr>
<h3 id="타입스크립트를-위한-환경-설정">타입스크립트를 위한 환경 설정</h3>
<h4 id="📃-tsconfig.json">📃 tsconfig.json</h4>
<pre><code class="language-json">{
  <span class="hljs-attr">"compilerOptions"</span>: {
    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"target"</span>: <span class="hljs-string">"ES5"</span>,
    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"CommonJS"</span>,
    <span class="hljs-attr">"alwaysStrict"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"noImplicitAny"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"noImplicitThis"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"downlevelIteration"</span>: <span class="hljs-literal">true</span>
  }
}</code></pre>
<p>compilerOptions에 대한 내용은 공식문서에 나와있고, 엄청나게 많다. 당장 다 보기에는 내용이 너무 방대하니 나중에 디테일이 필요할때 확인해보는 것을 추천한다.</p>
<ul>
<li><strong>strict: false</strong> : 점진적으로 javascript를 typescript로 전환할 수 있는 환경을 제공해줌. true 로하면 타입스크립트가 엄격해지긴하지만 알려주는 사항들이 많아서 편리하다.</li>
<li><strong>noImplicitAny: true</strong> : <code>any</code> 사용을 금지하고 명확한 타입을 요구한다.</li>
<li><strong>sourceMap: true</strong> : 설정은 브라우저에서도 타입스크립트 실행에 대한 정보를 얻을 수 있는 map파일을 생성해주는 옵션이다. - 개발환경과 실행환경을 일치시킬 수 있는 설정</li>
</ul>
<h3 id="변수에-타입-작성하기">변수에 타입 작성하기</h3>
<p>하나씩 타입 바꿔보는중.
<code>for</code>문에서 <code>let i</code>에 타입을 지정하지 않아도 뭐라고 하지 않는다? → 타입 추론. 타입스크립트가 기본적으로 코드를 보고 타입을 추론한다. </p>
<blockquote>
  <p>타입은 보통 몇 개의 표현식(코드)을 바탕으로 타입을 추론합니다. 그리고 그 표현식을 이용하여 가장 근접한 타입을 추론하게 되는데 이 가장 근접한 타입을 Best Common Type이라고 합니다.</p>
  <p>📌 출처 <a href="https://www.typescriptlang.org/ko/docs/handbook/type-inference.html">TypeScript: Documentation - Type Inference</a></p>
</blockquote>
<h3 id="함수의-규격-작성하기">함수의 규격 작성하기</h3>
<p>함수 타입을 설정해본다. 함수는 객체를 반환할때가 많은데 여러 객체에 대한 타입을 지정하다보면 중복되는 값들이 있다.</p>
<p>이때 공통된 타입들을 따로 빼서 이용할 수 있는데, <strong>인터섹션</strong>이라고 하는 <strong>타입 알리아스</strong>의 기능을 이용한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">type</span> Board = {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  title: <span class="hljs-built_in">string</span>;
  url: <span class="hljs-built_in">string</span>;
  user: <span class="hljs-built_in">string</span>;
  content: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">type</span> NoticeList = Board &amp; {
  <span class="hljs-attr">comments_count</span>: <span class="hljs-built_in">number</span>;
  points: <span class="hljs-built_in">number</span>;
  read?: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 물음표는 선택속성 이라는 뜻</span>
}

<span class="hljs-keyword">type</span> NoticeDetail = Board &amp; {
  <span class="hljs-attr">contents_count</span>: <span class="hljs-built_in">number</span>;
  comments?: NoticeComment[];
}

<span class="hljs-keyword">type</span> NoticeComment = Board &amp; {
  comments?: NoticeComment[];
  level: <span class="hljs-built_in">number</span>;
}</code></pre>
<p><code>getData</code>같이 범용으로 쓰이는 함수는 그때마다 리턴하는 객체가 다른데, 그 객체의 타입을 아래처럼 하나 하나 입력해주는 것은 말이 안될 것이다.</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">NoticeList</span>[] | <span class="hljs-title">NoticeDetail</span>[] </span>{
  ajax.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">false</span>);
  ajax.send();

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(ajax.response);
}</code></pre>
<p>이런 상황에서 유용한 <strong>generic</strong>이라는 기술이 있다. 많은 언어들에서 지원하는 기능이나, 유연한 기능이고 난이도가 상황에 따라 매우 높아질 수 있는 기술이다. 그래서 심플하게 이 예제에 맞게만 설명을 해주심.</p>
<ul>
<li>어떤 데이터가 리턴되는지 굉장히 모호한 상황을 해결해주는것.</li>
<li>입력이 n개일때 출력도 n개인 유형을 정의하는 것이 제네릭. 입력이 a이면 출력도 a ….</li>
</ul>
<h4 id="제네릭-관련-글">제네릭 관련 글</h4>
<ul>
<li><a href="https://www.typescriptlang.org/ko/docs/handbook/2/generics.html">TypeScript: Documentation - Generics</a></li>
<li><a href="https://hyunseob.github.io/2017/01/14/typescript-generic/">TypeScript: 제네릭(Generic) | DailyEngineering</a></li>
</ul>
<p><code>T</code>라는 유형을 받고 해당 함수가 <code>T</code>유형의 값을 반환하는 것. (반환 타입을 인자로 받는 느낌?)</p>
<p>아래 실제 사용할때 함수명과 괄호 사이에 꺽쇠를 작성하고 그 안에 return되는 값의 타입을 전달해줌.</p>
<p>호출부에서 타입을 지정하면 실제 실행될 때 타입을 그대로 받아서 해당 타입으로 반환.</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">T</span> </span>{
  ajax.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">false</span>);
  ajax.send();

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(ajax.response);
}

makeNoticeList(getData&lt;NoticeList[]&gt;(NEWS_URL))</code></pre>
<p>보통 제네릭 이름을 <code>T</code>로 많이 사용하기도하고, 명시적인 이름을 사용하기도 한다. 선생님은 명시적은 이름을 선호하신다고.</p>
<h4 id="vscode-extension-추천-:-REST-Client">vscode extension 추천 : REST Client</h4>
<p>hm.http 파일을 생성하고 아래와 같이 입력하면 Send Request 버튼이 활성화 된다.</p>
<p><code>#</code>도 꼭 입력!</p>
<p>Send Request버튼을 클릭하면 오른쪽 패널처럼 응답을 확인할 수 있다.</p>
<pre><code>###
GET https://api.hnpwa.com/v0/notice/1.json HTTP/1.1</code></pre>
<figure>
  <img src="/posts/images/fastcampus-javascript-typescript-essential-2/i41g-230203-154150.png" alt="vscode extension - REST Client 실행 화면">
  <figcaption>이야! 신기</figcaption>  
</figure>
<h3 id="타입과-인터페이스">타입과 인터페이스</h3>
<p>지금까지 타입 알리아스라고 하는 기능을 사용해서 타이핑을 해왔다.</p>
<p>타입 알리아스 말고 인터페이스라는 기능도 있는데.</p>
<p>코드 가독성이 좋아지는 것 같다. 확장되는 형식의 타입들에는 특히 인터페이스를 선호한다고 한다.</p>
<h4 id="타입-알리아스">타입 알리아스</h4>
<p>위에서 작성했던 방식이 타입 알리아스.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">type</span> Board = {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  title: <span class="hljs-built_in">string</span>;
  url: <span class="hljs-built_in">string</span>;
  user: <span class="hljs-built_in">string</span>;
  content: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">type</span> NoticeList = Board &amp; {
  <span class="hljs-attr">comments_count</span>: <span class="hljs-built_in">number</span>;
  points: <span class="hljs-built_in">number</span>;
  read?: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 물음표는 선택속성 이라는 뜻</span>
}

<span class="hljs-keyword">type</span> NoticeDetail = Board &amp; {
  <span class="hljs-attr">contents_count</span>: <span class="hljs-built_in">number</span>;
  comments?: NoticeComment[];
}</code></pre>
<h4 id="인터페이스">인터페이스</h4>
<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> Board = {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;
  title: <span class="hljs-built_in">string</span>;
  url: <span class="hljs-built_in">string</span>;
  user: <span class="hljs-built_in">string</span>;
  content: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">interface</span> NoticeList <span class="hljs-keyword">extends</span> Board {
  <span class="hljs-attr">comments_count</span>: <span class="hljs-built_in">number</span>;
  points: <span class="hljs-built_in">number</span>;
  read?: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 물음표는 선택속성 이라는 뜻</span>
}

<span class="hljs-keyword">interface</span> NoticeDetail <span class="hljs-keyword">extends</span> Board {
  <span class="hljs-attr">contents_count</span>: <span class="hljs-built_in">number</span>;
  comments?: NoticeComment[];
}</code></pre>
<p>유니온 타입인 Atype | Btype 형식으로 타입을 지정해야한다면, 인터페이스는 지원되지 않는 기능이기 때문에 타입 알리아스를 사용해야한다. 그 외에는 인터페이스를 주로 많이 사용하는 경향이 있다고 한다.</p>
<p>바뀌면 안되는 읽기만 하는 속성은 <code>readonly</code>로 수정 불가능하게 할 수 있다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> Board = {
  <span class="hljs-keyword">private</span> id: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">private</span> title: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">private</span> url: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">private</span> user: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">private</span> content: <span class="hljs-built_in">string</span>;
}</code></pre>
<h3 id="상속과-믹스인">상속과 믹스인</h3>
<p>api 를 통해 데이터를 가져와 리턴하는 함수를 <code>extends</code>를 이용한 클래스 상속으로 리팩토링. </p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getData</span>&lt;<span class="hljs-title">AjaxResponse</span>&gt;(<span class="hljs-params">url: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">AjaxResponse</span> </span>{
  ajax.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">false</span>);
  ajax.send();

  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(ajax.response);
}

<span class="hljs-comment">// ...</span>
noticeList = store.noticeList = makeFeeds(getData&lt;NoticeList[]&gt;(NEWS_URL))</code></pre>
<h4 id="믹스인">믹스인</h4>
<ul>
<li><code>class</code>를 마치 함수처럼, 단독 객체처럼 바라보면서 필요할때마다 확장해나가는 기법</li>
<li><code>class</code>를 훨씬 독립적인 주체로 바라보기때문에 <code>class</code>들을 상하위 관계로 바라보지않는다</li>
<li>믹스인은 언어의 문법으로 제공되는게 아니라, 코드 테크닉으로 전개되는 기법이다</li>
<li>유연성이 필요할때 믹스인을 사용함.</li>
<li>상위 클래스가 여러개이고 싶을때 믹스인을 사용함</li>
</ul>
<h4 id="extends">extends</h4>
<ul>
<li>기존 <code>extends</code>라는 상속방법은 코드에 적시되어야 하는 상속 방법이다.</li>
<li>상속의 관계를 바꾸고 싶으면 코드 자체를 바꿔야한다는 말이다. → 관계를 유연하게 가져갈 수 없음</li>
<li><code>class extends</code>문법은 다중 상속을 지원하지 않음</li>
</ul>
<p>타입 스크립트 공식 페이지에도 나와있는 믹스인 함수</p>
<p>믹스인을 구현하는 방법은 여러가지고 있고 요건 그 중 한가지.</p>
<pre><code class="language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyApiMixins</span>(<span class="hljs-params">targetClass: <span class="hljs-built_in">any</span>, baseClasses: <span class="hljs-built_in">any</span>[]</span>) </span>{
  baseClasses.forEach(<span class="hljs-function"><span class="hljs-params">baseClass</span> =&gt;</span> {
    <span class="hljs-built_in">Object</span>.getOwnPropertyNames(baseClass.prototype).forEach(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> descriptor = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(baseClass.prototype, name)

      <span class="hljs-keyword">if</span>(descriptor) {
        <span class="hljs-built_in">Object</span>.defineProperty(targetClass.prototype, name, descriptor)
      }
    })
  })
}</code></pre>
<p>그리고 <code>extends</code>에서 바꾼 <code>class</code>들</p>
<pre><code class="language-typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Api</span> </span>{
  getRequest&lt;AjaxResponse&gt;(url: <span class="hljs-built_in">string</span>): AjaxResponse {
    <span class="hljs-keyword">const</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest()
    ajax.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">false</span>);
    ajax.send();

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(ajax.response);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeListApi</span> </span>{
  getData(): NoticeList[] {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRequest&lt;NoticeList[]&gt;(url);
  }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoticeDetailApi</span> </span>{
  getData(id: <span class="hljs-built_in">string</span>): NoticeDetail {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getRequest&lt;NoticeDetail&gt;(id);
  }
}
<span class="hljs-comment">// typescript에게 두개의 클래스를 합쳤다는 것을 알려줘야. this.getRequest를 사용할 수 있다.</span>
<span class="hljs-keyword">interface</span> NoticeListApi <span class="hljs-keyword">extends</span> Api {}
<span class="hljs-keyword">interface</span> NoticeDetailApi <span class="hljs-keyword">extends</span> Api {}

applyApiMixins(NoticeListApi, [Api])
applyApiMixins(NoticeDetailApi, [Api])</code></pre>
<p>믹스인은 좀 번거로운 측면이 있어 일반적인 프로젝트에서는 클래스만 사용해도 큰 문제가 없고, 실제로도 클래스가 많이 사용되고 있다. 하지만 유연성이 필요한 프로젝트에서는 믹스인을 많이 사용하고 개발자 성향에 따라 믹스인을 적극적으로 사용하는 프로젝트도 있다고 한다.</p>
<h3 id="View-class로-코드-구조-개선">View class로 코드 구조 개선</h3>
<p>일단 클래스를 만들고, 클래스로 만들 함수의 내용들을 일단 <code>constructor</code>에 넣어본다.</p>
<p>그리고 <code>constructor</code>에 남아야될것, 메서드로 빼야할것들을 위치를 옮겨보며 의사코드를 작성한다.</p>
<p>디테일들을 다듬어준 뒤, 하나씩 디버깅하면서 완성했다.</p>
<blockquote>
  <p><strong>의사코드</strong>: 대략 이런흐름으로 코드가 전개되면 좋을것 같아 라고 문법도 크게 신경쓰지않고 작성해놓은 코드를 말한다.</p>
</blockquote>
<p>그리고 코드 디테일. 외부로부터 접근할 속성/함수가 아닌경우엔 </p>
<p>외부라는 범주도 2개로 나눌수있다. 이 2가지 케이스에 대한 속성 접근자가 다르다.</p>
<ul>
<li>클래스 내부 까지:  <strong>private</strong> (자식에서도 접근 불가)</li>
<li>상속받은 자식 class 까지: <strong>protected</strong></li>
<li>아예 관련없는 바깥쪽까지: <strong>public</strong> (default)</li>
</ul>
<p>이부분은 흐름이 좀 빠르기도하고, 완벽히 이해가 안된 부분들도 있어서 다시 봐봐도 좋을 것 같다.</p>
<h3 id="파일의-분리,-더욱-성장할-앱을-위한-준비">파일의 분리, 더욱 성장할 앱을 위한 준비</h3>
<p>폴더에 index.ts파일을 만들어서</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> NoticeDetailView } <span class="hljs-keyword">from</span> <span class="hljs-string">'./notice-detail-view'</span>
<span class="hljs-keyword">export</span> { <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> noticeListView } <span class="hljs-keyword">from</span> <span class="hljs-string">'./notice-feed-view'</span></code></pre>
<p>이런식으로 하위 모듈들의 <code>default</code>를 가져와 이름만 내보낸다.</p>
<p>이랬던 <code>import</code>문들이</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> NoticeDetailView <span class="hljs-keyword">from</span> <span class="hljs-string">'./page/notice-detail-view'</span>
<span class="hljs-keyword">import</span> NoticeListView <span class="hljs-keyword">from</span> <span class="hljs-string">'./page/notice-feed-view'</span></code></pre>
<p>이렇게 바뀐다.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { NoticeDetailView, NoticeListView } <span class="hljs-keyword">from</span> <span class="hljs-string">'./page'</span></code></pre>
<p>이렇게 하면 page 하위 디렉토리 구조에 대해 전혀 신경쓰지 않아도 된다.</p>
<p>추후 페이지가 많아져서 파일명등 경로가 바뀌었다고 하더라도 index.ts에서 경로만 바꾸면 되니까 <code>import</code> 하는쪽에서 하나하나 다 바꿔주지않아도 된다는 장점이있어서 많이 사용된다고한다.</p>
<h3 id="안전한-전역-상태-관리">안전한 전역 상태 관리</h3>
<p><code>store</code>를 전역 객체인 <code>window</code> 속성으로 지정해둔 상태.</p>
<p>모든 <code>class</code>에서 접근가능. 전역 속성은 편리하지만 위험하기도 하다. 어딘가에서 의도치않은 수정. 버그 발생.</p>
<p>때문에  전역 속성은 가능한 사용하지 않는 것이 좋다.</p>
<p>그래서 기존에 전역 속성으로 지정한 <code>store</code>를 <code>class</code>로 분리한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> </span>{
  <span class="hljs-attr">noticeList</span>: NoticeList[]
  <span class="hljs-attr">currentPage</span>: <span class="hljs-built_in">number</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.noticeList = []
    <span class="hljs-built_in">this</span>.currentPage = <span class="hljs-number">1</span>
  }
}</code></pre>
<p>이렇게만 작업되면 다른 클래스에서 <code>store</code>의 속성값들을 수정하는 것은 여전히 제어가 안되고있다.</p>
<p>원천적으로 잘못 세팅되는것을 방어해야한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> </span>{
  <span class="hljs-keyword">private</span> noticeList: NoticeList[]
  <span class="hljs-keyword">private</span> currentPage: <span class="hljs-built_in">number</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.noticeList = []
    <span class="hljs-built_in">this</span>.currentPage = <span class="hljs-number">1</span>
  }
}</code></pre>
<p>이렇게 <code>private</code> 키워드로 외부에 노출되지 않도록 바꿀 수 있다.</p>
<p>하지만 외부 <code>class</code>에서 이 데이터들을 세팅도 하고 읽기도 해야 하는데 현재는 불가능하다.</p>
<p>이럴 때, <strong>세팅과 데이터 읽기에 해당하는 기능을 별도로 제공</strong>해줄 수 있다.</p>
<p><code>currentPage</code>에 대한 내용부터 처리해본다.</p>
<p>해당 데이터를 읽을 수 있는 <code>getCurrentPage</code>라는 메서드를 생성할 수 있겠지만, 고작 숫자 하나 가져오는데 메서드가 장황하다.</p>
<p>이럴때 내부에서는 함수로 작동하지만 외부에서는 속성처럼 보이게 하는 <code>getter</code>/<code>setter</code> 문법이 존재한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> </span>{
  <span class="hljs-keyword">private</span> noticeList: NoticeList[]
  <span class="hljs-keyword">private</span> currentPage: <span class="hljs-built_in">number</span>

  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> {
    <span class="hljs-built_in">this</span>.noticeList = []
    <span class="hljs-built_in">this</span>.currentPage = <span class="hljs-number">1</span>
  }

  <span class="hljs-keyword">get</span> <span class="hljs-title">currentPage</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._currentPage
  }
}</code></pre>
<p>이렇게 <code>currentPage</code>에 대한 <code>getter</code>를 생성했다.</p>
<p>자세히 보면 속성값에 언더바가 추가되어있는데, <code>getter</code>와 속성값이 동일하면 안되기도하고 내부에서 쓰이는 속성은 보통 언더바를 붙인다고 한다.</p>
<p><code>currentPage</code> 는 url의 해시값을 통해, 데이터를 세팅하기도 하기 때문에 <code>setter</code>도 설정해줘야한다.</p>
<p>외부에서는 마치 속성인것처럼 대입문으로 세팅도 하거나 속성 값으로 읽어갈 수도 있다. 하지만 내부에서는 함수이기 때문에 잘못된 값으로 세팅되거나 특정한 범위 내의 값으로만 한정시키는 조건들을 지정해줄 수 있다.</p>
<p>예를들면 이렇게.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">set</span> <span class="hljs-title">currentPage</span>(<span class="hljs-params">page: <span class="hljs-built_in">number</span></span>) {
    <span class="hljs-keyword">if</span>(page &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>
    <span class="hljs-built_in">this</span>._currentPage = page
  }</code></pre>
<p>대입문으로 값을 넣을 수 없기 때문에 일종의 <code>readOnly</code> 데이터라고 볼 수 있다.</p>
<p>이런식으로 필요한 메서드들을 차근차근 추가 후, app.ts에서 <code>store</code>를 불러오고 <code>store</code>가 필요한 인스턴스에 인자로 <code>store</code>를 넘겼다.</p>
<p>각 <code>class</code>에 <code>store</code> 인수를 추가하고 데이터를 설정하는데, 이때 해당 <code>store</code>의 타입을 지정해줘야 하기때문에 또 새로운 인터페이스를 만들어줘야한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> NoticeStore {
  <span class="hljs-attr">getAllNoticeList</span>: <span class="hljs-function">() =&gt;</span> NoticeBoard[]
  <span class="hljs-attr">getNoticeBoard</span>: <span class="hljs-function">(<span class="hljs-params">position: <span class="hljs-built_in">number</span></span>) =&gt;</span> NoticeBoard
  <span class="hljs-attr">setNoticeList</span>: <span class="hljs-function">(<span class="hljs-params">feeds: NoticeBoard[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>
  <span class="hljs-attr">makeRead</span>: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>
  <span class="hljs-attr">hasNoticeList</span>: <span class="hljs-built_in">boolean</span>
  <span class="hljs-attr">currentPage</span>: <span class="hljs-built_in">number</span>
}</code></pre>
<p>이렇게 만들었던 메서드들에 대한 타입을 지정해주는데, 아까 만들었어 <code>getter</code>/<code>setter를</code> 함수로 만들었다고해서 인터페이스쪽에 함수로 작성하면 안된다. 외부로 드러나는 형식을 기준으로 작성해줘야한다.</p>
<p>이렇게 작성한 인스턴스의 인터페이스를 <code>Store</code> 클래스랑 연결시켜줘야한다.</p>
<p>실제 이 인터페이스를 구현한 <code>class</code>다 라는 의미로 <code>implements NoticeStore</code> 라고 작성해주면된다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> <span class="hljs-title">implements</span> <span class="hljs-title">NoticeStore</span> </span>{
  <span class="hljs-comment">// ...</span>
}</code></pre>
<p>어떤 데이터를 수정하는 코드들은 그 역할에 충실할 수 있는 class를 만들어서 제공하면 훨씬 더 안전한 코드를 제공할 수 있다.</p>
<p>코드도 깔끔해지고 코드 양도 줄어들고!</p>
<h3 id="XHR-to-Fetch-&amp;-Promise">XHR to Fetch &amp; Promise</h3>
<ul>
<li>동기 실행으로 설정되어있던 <code>XMLHttpRequest</code>를 비동기 실행으로 설정하고, <code>getRequest</code> 메서드를 데이터 return에서 콜백함수를 인자로 받도록 변경했다.</li>
<li>해당 메서드를 사용하는 곳에서 데이터를 응답받아 실행되어야하는 로직들을 <code>getRequest</code> 콜백함수로 넘겨줬다.</li>
<li>하지만 이렇게 콜백으로 실행되면 호출해야하는 api 갯수가 많아질때 콜백지옥이 열릴 수 있기 때문에 Promise를 사용해서 이 문제를 해결해볼 수 잇다.</li>
<li>xhr이 여러 단점들을 가지고 있어서 그 단점들을 보완하여 이후에 나온 Promise 베이스의 fetch라는 api를 사용한다.</li>
<li><code>fetch</code>는 <code>Promise</code>를 반환하는데 <code>Promise</code>는 then이라는 메서드를 제공한다. 요걸 이용해서 콜백헬을 일자로 쭉 펼쳐서 해결할 수 있다.</li>
<li><code>fetch</code>에서 받은 응답은 json을 parse하는 메서드를 가지고 있다. <code>JSON.parse</code> 메서드도 있는데 왜 따로 제공하냐면, <strong><code>JSON.parse</code>는 동기적으로 작동</strong>하기 때문에 데이터가 양이 많을때 parse하는동안 어플리케이션이 멈추게 된다. 하지만 <strong><code>fetch</code> 응답의 json parse메서드는 비동기적</strong>으로 실행된다.</li>
<li>비동기 함수를 다루는 패턴은 아주 다양하고, 꾸준한 공부가 필요하다. 여러 문서, 샘플들을 참고하길 바란다.</li>
</ul>
<h3 id="콜백-함수-없는-비동기-코드-작성법">콜백 함수 없는 비동기 코드 작성법</h3>
<p>비동기 코드를 어떻게하면 잘 처리할 수 있을까에 대해 많은 고민들이 오랫동안 있어왔다.</p>
<p>그것을 해결하기 위한 방법 중 하나가 위에서 했던 Promise 이고, 또 하나는 <code>async</code>/<code>await</code> 가 있는데 비동기 방식이지만 코드 형태는 동기와 비슷하다.</p>
<p>typescript에서 <code>async</code>/<code>await</code>를 설정하려면 tsconfig 설정을 해주야 한다.</p>
<p>target을 없애고 lib을 추가해준다.</p>
<pre><code class="language-json">{
  <span class="hljs-attr">"compilerOptions"</span>: {
    <span class="hljs-attr">"strict"</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-comment">//"target": "ES6", 제거</span>
    <span class="hljs-attr">"module"</span>: <span class="hljs-string">"CommonJS"</span>,
    <span class="hljs-attr">"alwaysStrict"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"noImplicitAny"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"noImplicitThis"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"sourceMap"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"downlevelIteration"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"lib"</span>: [ <span class="hljs-comment">//추가</span>
      <span class="hljs-string">"es6"</span>,
      <span class="hljs-string">"dom"</span>
    ]
  }
}</code></pre>
<p>기존 함수 앞에 <code>async</code>를 붙여주면 이제 그 함수는 비동기 함수가 된다. <code>Promise</code> 객체를 리턴하는 함수가 된다는 뜻.</p>
<p>함수 반환 타입을 <code>Promise</code>로 교체하고, <code>fetch</code> 앞에 <code>await</code> 오퍼레이터를 붙여준다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">async</span> request&lt;AjaxResponse&gt;(cb: <span class="hljs-function">(<span class="hljs-params">data: AjaxResponse</span>) =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-built_in">Promise</span>&lt;AjaxResponse&gt; {
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-built_in">this</span>.url)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.json() <span class="hljs-keyword">as</span> AjaxResponse
}</code></pre>
<p>비동기 함수를 호출하는 함수도 비동기 함수여야 한다.</p>
<p>따라서 <code>request</code>를 호출 하는 하위 <code>class</code>의 <code>getData</code>메서드 앞에도 <code>async</code>를 붙여주고 반환타입 <code>Promise</code>로 설정</p>
<pre><code class="language-typescript"><span class="hljs-keyword">async</span> getData(): <span class="hljs-built_in">Promise</span>&lt;NoticeList[]&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.request&lt;NoticeList[]&gt;()
}</code></pre>
<p><code>async</code> 함수는 반환값이 없더라도 <code>Promise</code> 로 꼭 감싸줘야 한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">async</span> render(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
  <span class="hljs-keyword">const</span> api = <span class="hljs-keyword">new</span> NoticeDetailApi()
  <span class="hljs-keyword">const</span> { title, content, comments } = <span class="hljs-keyword">await</span> api.getData()

  <span class="hljs-comment">//...</span>
}</code></pre>
<p>이제 함수가 동기 코드화 됐으니까, 기존에 비동기 코드라서 renderView를 따로 만들어서 분리했었던걸 다시 render로 이동시킬 수 있다.</p>
<p>async await는 아주 강력한 기능인데, promise에 대한 이해를 충분히 하고 써야 문제없이 사용할 수 있다.</p>
<hr>
<h3 id="후기">후기</h3>
<ul>
<li><p>이번에는 코드를 이관하고 리팩토링하는 작업들이 많아서 그런지 속도가 좀 빨라서 다시 되돌려가며 여러번 봤다.</p></li>
<li><p>generic, implements, as… 바로 이해안되는 개념들도 있었지만, 깊게 파지 않고 우선 대략적으로 이해하고 쭉 진도 나갔다. 나중에 더 보기 표시 해뒀다. 아직 깊게 팔 짬은 아니다.</p></li>
<li><p>알고 있던 개념들도 뭔가 지식이 더 채워지는 기분! 좋았다.</p></li>
<li><p>감은 좀 잡히는 기분인데, 토이프로젝트 typescript 쪼꼼씩 이관 도전!?</p></li>
</ul></div><div class="article-bottom" data-v-0cc18c81=""><p class="text-ps" data-v-0cc18c81=""><strong data-v-0cc18c81="">수정이 필요한 부분</strong> 혹은 <strong data-v-0cc18c81="">더 나은 방법</strong>을 알고계신가요? <br data-v-0cc18c81=""> 댓글로 알려주시면 저에게 큰 도움이 됩니다! 😊💜 </p><div class="vue-utterances" data-v-0cc18c81=""><div class="utterances" style="height: 269px;">
    <iframe class="utterances-frame" title="Comments" scrolling="no" src="https://utteranc.es/utterances.html?async=&amp;src=https%3A%2F%2Futteranc.es%2Fclient.js&amp;repo=yemsu%2Fyemsu.github.io&amp;issue-term=pathname&amp;theme=github-light&amp;crossorigin=anonymous&amp;url=http%3A%2F%2Flocalhost%3A8000%2Ffastcampus-javascript-typescript-essential-2&amp;origin=http%3A%2F%2Flocalhost%3A8000&amp;pathname=fastcampus-javascript-typescript-essential-2&amp;title=ENJOY+DEV&amp;description=&amp;og%3Atitle=&amp;session=" loading="lazy"></iframe>
  </div></div></div></article></div><footer data-v-183da9a0=""> copyright © <a href="https://github.com/yemsu" target="_blank" title="Github (새창)" data-v-183da9a0="">yemsu</a>. All right reserved. </footer></div><script src="/js/chunk-vendors.js"></script><script src="/js/app.js"></script><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none !important;"><div id="aswift_0_host" style="border: none; height: 0px; width: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;" tabindex="0" title="Advertisement" aria-label="Advertisement"><iframe id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0;width:undefinedpx;height:undefinedpx;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-4052679554213032&amp;output=html&amp;adk=1812271804&amp;adf=3025194257&amp;lmt=1680748364&amp;plat=1%3A8%2C2%3A8%2C3%3A2162688%2C4%3A2162688%2C9%3A32776%2C16%3A8388608%2C17%3A32%2C24%3A32%2C25%3A32%2C30%3A1048576%2C32%3A32%2C41%3A32%2C42%3A32&amp;format=0x0&amp;url=http%3A%2F%2Flocalhost%3A8000%2Ffastcampus-javascript-typescript-essential-2&amp;ea=0&amp;pra=5&amp;wgl=1&amp;dt=1680748369691&amp;bpp=16&amp;bdt=1150&amp;idt=305&amp;shv=r20230404&amp;mjsv=m202303300101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;nras=1&amp;correlator=7246790186775&amp;frm=20&amp;pv=2&amp;ga_vid=1429481155.1680748369&amp;ga_sid=1680748370&amp;ga_hid=1465476117&amp;ga_fc=1&amp;u_tz=540&amp;u_his=2&amp;u_h=600&amp;u_w=800&amp;u_ah=600&amp;u_aw=800&amp;u_cd=24&amp;u_sd=1&amp;dmc=8&amp;adx=-12245933&amp;ady=-12245933&amp;biw=800&amp;bih=600&amp;scr_x=0&amp;scr_y=0&amp;eid=42532176%2C44759842%2C44759927%2C44759876%2C42532089%2C31073585&amp;oid=2&amp;pvsid=1463157073545803&amp;tmod=1368089708&amp;uas=0&amp;nvt=1&amp;fc=1920&amp;brdim=0%2C0%2C0%2C0%2C800%2C0%2C800%2C600%2C800%2C600&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=33792&amp;bc=31&amp;ifi=1&amp;uci=a!1&amp;fsb=1&amp;dtd=415" data-google-container-id="a!1" data-load-complete="true"></iframe></div></ins></body><iframe id="google_esf" name="google_esf" src="https://googleads.g.doubleclick.net/pagead/html/r20230404/r20190131/zrt_lookup.html" style="display: none;"></iframe></html>