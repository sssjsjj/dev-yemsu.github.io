<!DOCTYPE html><html lang="ko"><head>
        <title>[TIL] JavaScript & TypeScript Essential - Chapter 6</title>
        <meta name="title" content="[TIL] JavaScript & TypeScript Essential - Chapter 6" />
        <meta name="description" content="Fastcampus의 김민태의 프론트엔드 아카데미 : 제 1 강 JavaScript & TypeScript Essential 강의 Chapter 6를 수강하며 기록한 내용 입니다." />
        <meta name="keywords" content="Fastcampus,김민태의 프론트엔드 아카데미" />
        <meta property="og:url" content="https://yemsu.github.io/fastcampus-javascript-typescript-essential-3" />
        <meta property="og:type" content="article" />
        <meta property="og:title" content="[TIL] JavaScript & TypeScript Essential - Chapter 6" />
        <meta property="og:description" content="Fastcampus의 김민태의 프론트엔드 아카데미 : 제 1 강 JavaScript & TypeScript Essential 강의 Chapter 6를 수강하며 기록한 내용 입니다." />
        <meta property="og:image" content="https://yemsu.github.io/images/og_image.jpg" />
        <meta property="twitter:card" content="https://yemsu.github.io/images/og_image.jpg" />
        <meta property="twitter:url" content="https://yemsu.github.io/fastcampus-javascript-typescript-essential-3" />
        <meta property="twitter:title" content="[TIL] JavaScript & TypeScript Essential - Chapter 6" />
        <meta property="twitter:description" content="Fastcampus의 김민태의 프론트엔드 아카데미 : 제 1 강 JavaScript & TypeScript Essential 강의 Chapter 6를 수강하며 기록한 내용 입니다." />
        <meta property="twitter:image" content="https://yemsu.github.io/images/og_image.jpg" />
      <style>
    .utterances {
      position: relative;
      box-sizing: border-box;
      width: 100%;
      max-width: 760px;
      margin-left: auto;
      margin-right: auto;
    }
    .utterances-frame {
      color-scheme: light;
      position: absolute;
      left: 0;
      right: 0;
      width: 1px;
      min-width: 100%;
      max-width: 100%;
      height: 100%;
      border: 0;
    }
  </style><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2284%22>🌊</text></svg>"><title>ENJOY DEV</title><meta name="naver-site-verification" content="c702bde42c5742aa62750f39d810dd87c91f4811"><meta name="google-site-verification" content="rRA_cKc94OITZM0hBG9JQUQBl8IbTx9G7cY6mUo1hgw"><script src="https://partner.googleadservices.com/gampad/cookie.js?domain=localhost&amp;callback=_gfp_s_&amp;client=ca-pub-4052679554213032"></script><script src="https://pagead2.googlesyndication.com/pagead/managed/js/adsense/m202302160101/show_ads_impl.js" id="google_shimpl"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-922R4CGCRZ"></script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4052679554213032" crossorigin="anonymous" data-checked-head="true"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-922R4CGCRZ');</script><link href="/css/chunk-74d2d95d.css" rel="prefetch"><link href="/css/chunk-773fa2dd.css" rel="prefetch"><link href="/js/chunk-74d2d95d.js" rel="prefetch"><link href="/js/chunk-773fa2dd.js" rel="prefetch"><link href="/css/app.css" rel="preload" as="style"><link href="/js/app.js" rel="preload" as="script"><link href="/js/chunk-vendors.js" rel="preload" as="script"><link href="/css/app.css" rel="stylesheet"><link rel="stylesheet" type="text/css" href="/css/chunk-74d2d95d.css"><script charset="utf-8" src="/js/chunk-74d2d95d.js"></script><meta http-equiv="origin-trial" content="Az6AfRvI8mo7yiW5fLfj04W21t0ig6aMsGYpIqMTaX60H+b0DkO1uDr+7BrzMcimWzv/X7SXR8jI+uvbV0IJlwYAAACFeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A+USTya+tNvDPaxUgJooz+LaVk5hPoAxpLvSxjogX4Mk8awCTQ9iop6zJ9d5ldgU7WmHqBlnQB41LHHRFxoaBwoAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A7FovoGr67TUBYbnY+Z0IKoJbbmRmB8fCyirUGHavNDtD91CiGyHHSA2hDG9r9T3NjUKFi6egL3RbgTwhhcVDwUAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><link rel="preload" href="https://adservice.google.co.kr/adsid/integrator.js?domain=localhost" as="script"><script type="text/javascript" src="https://adservice.google.co.kr/adsid/integrator.js?domain=localhost"></script><link rel="preload" href="https://adservice.google.com/adsid/integrator.js?domain=localhost" as="script"><script type="text/javascript" src="https://adservice.google.com/adsid/integrator.js?domain=localhost"></script></head><body><noscript><strong>We're sorry but ENJOY DEV doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app" data-v-app=""><metainfo></metainfo><header data-v-49c83e62=""><h1 data-v-49c83e62=""><a href="/" class="logo size-medium" data-v-295f0452="" data-v-49c83e62=""><span class="logo-text dev" data-v-295f0452=""> D<span class="hidden" data-v-295f0452="">E</span>V </span><span class="logo-text enjoy" data-v-295f0452=""><span class="common-e" data-v-295f0452="">E</span>NJOY🌊 </span></a></h1><div class="links" data-v-49c83e62=""><a href="https://github.com/yemsu/" title="Yemsu Github" target="_blank" data-v-49c83e62=""><svg aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="26" data-view-component="true" class="octicon octicon-mark-github v-align-middle"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></div></header><div class="container size-narrow" data-v-5006e508="" data-v-0cc18c81=""><nav class="outLiner" data-v-0cc18c81=""><h2 class="ir">글 목차 (클릭하여 바로가기)</h2><ul><li class=""><a href="#6-1.-문법-식별자">6-1. 문법-식별자</a></li><li class="title-sub"><a href="#컨밴션">컨밴션</a></li><li class=""><a href="#6-2.-문법-값(value)">6-2. 문법-값(value)</a></li><li class="title-sub"><a href="#튜플-(Tuple)">튜플 (Tuple)</a></li><li class="title-sub"><a href="#열거형-(Enum)">열거형 (Enum)</a></li><li class="title-sub"><a href="#Any">Any</a></li><li class="title-sub"><a href="#Void">Void</a></li><li class="title-sub"><a href="#Never">Never</a></li><li class="title-sub"><a href="#객체">객체</a></li><li class=""><a href="#6-3.-문법-타입">6-3. 문법-타입</a></li><li class="title-sub"><a href="#javascript">javascript</a></li><li class="title-sub"><a href="#typescript">typescript</a></li><li class=""><a href="#6-4.-문법-변수(&amp;상수)">6-4. 문법-변수(&amp;상수)</a></li><li class=""><a href="#6-5.-문법-식(연산-또는-계산)">6-5. 문법-식(연산 또는 계산)</a></li><li class=""><a href="#6-6.-문법-참조와-복사">6-6. 문법-참조와 복사</a></li><li class=""><a href="#6-7.-문법-조건(분기)문">6-7. 문법-조건(분기)문</a></li><li class=""><a href="#6-8.-문법-반복문">6-8. 문법-반복문</a></li><li class=""><a href="#6-9.-문법-예외">6-9. 문법-예외</a></li><li class=""><a href="#6-10.-문법-인터페이스와-타입-별칭">6-10. 문법-인터페이스와 타입 별칭</a></li><li class="title-sub"><a href="#타입알리아스">타입알리아스</a></li><li class="title-sub"><a href="#인터페이스">인터페이스</a></li></ul></nav><!----><article data-v-0cc18c81="" style=""><div class="wrap-info" data-v-0cc18c81=""><h2 class="title" data-v-0cc18c81="">[TIL] JavaScript &amp; TypeScript Essential - Chapter 6</h2><p class="date" data-v-0cc18c81="">2023-2-4</p><ul class="keywords" data-v-0cc18c81=""><li class="keyword" data-v-0cc18c81="">Fastcampus</li><li class="keyword" data-v-0cc18c81="">김민태의 프론트엔드 아카데미</li></ul></div><div class="article" data-v-0cc18c81=""><p>5장은 로그인, 회원가입 등 실전예제에 대한 내용이다. 순서대로라면 5장을 들어야하지만, 선생님께서 하신 말씀을 요약하자면 아래와 같다.</p>
<blockquote>
  <p>5장은 다른 장에 비해 강의 시간이 짧은 편이다. 덜 중요해서가 아니고, 가장 중요한 장이지만 개발 공부에 대한 가이드를 잡아주고 나머지는 여러분이 자가 학습 역량을 발휘해 스스로 하기를 바라는 마음에서이다.<br>
  예제들은 시작점이라고 생각하고, 각각의 앱들에 살을 붙여가면서 여러 아키텍쳐/방법론을 적용해보면 좋겠다. 다른 장들을 수강한 다음에 5장 수강을 권한다.</p>
</blockquote>
<p>알겠습니다! 6장으로 감미다.</p>
<p>6장의 타이틀은 '참조 사전'으로, 문법/개념/기법 등에 대한 전반적인 내용이다.</p>
<p>기본적인 내용들도 많지만, 개념들을 다잡기 위해 건너뛰진 않고 빠르게 훑으면서 수강했다.</p>
<hr>
<h3 id="6-1.-문법-식별자">6-1. 문법-식별자</h3>
<ul>
<li>변수, 함수, 속성명을 작성할때 유니코드 글자, $ _ 숫자로 구성할 수 있지만, 숫자로 시작할 수 없다.</li>
<li>공백 사용 불가.</li>
<li>길이제한은 딱히 없으나 가독성을 위해 적당한 길이로 작성.</li>
<li>코드는 데이터로 변환할 수 없지만 데이터는 식별자로 변환할 수 있다. ex.<code>object['key']</code></li>
</ul>
<h4 id="컨밴션">컨밴션</h4>
<ul>
<li>상수는 대문자로 이름 짓는다.</li>
<li>변수 이름은 카멜 케이스, 스네이크 케이스를 주로 쓰지만 카멜 케이스가 가장 흔히 쓰인다.</li>
</ul>
<h3 id="6-2.-문법-값(value)">6-2. 문법-값(value)</h3>
<ul>
<li>자바스크립트에서 값이라는 주제는 굉장히 광범위한 주제이다. 100시간을 해도 모자랄 정도로 내용이 방대하다.</li>
<li>다른언어와 굉장히 다른부분들도 있다. 자바스크립트는 값으로 취급하는 범위가 굉장히 넓음.</li>
<li>기본 자료형. 자바스크립트 내에서 코드가 아닌 데이터로서의 규격들이 어떤 것이 있는가 하는것.</li>
</ul>
<h4 id="튜플-(Tuple)">튜플 (Tuple)</h4>
<blockquote>
  <p>튜플 타입을 사용하면, 요소의 타입과 개수가 고정된 배열을 표현할 수 있습니다. 단 요소들의 타입이 모두 같을 필요는 없습니다. 예를 들어,&nbsp;number,&nbsp;string&nbsp;이 쌍으로 있는 값을 나타내고 싶을 수 있습니다.<br>
  📌 출처 - <a href="https://typescript-kr.github.io/pages/basic-types.html#%ED%8A%9C%ED%94%8C-tuple">튜플 | 기본타입 | typescript GitBook</a></p>
</blockquote>
<pre><code class="language-typescript"><span class="hljs-comment">// 튜플 타입으로 선언</span>
<span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>];
<span class="hljs-comment">// 초기화</span>
x = [<span class="hljs-string">"hello"</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// 성공</span>
<span class="hljs-comment">// 잘못된 초기화</span>
x = [<span class="hljs-number">10</span>, <span class="hljs-string">"hello"</span>]; <span class="hljs-comment">// 오류</span></code></pre>
<p>첫번째는 문자열만, 두번째는 숫자만 들어가는 배열을 만들고싶어! 할때 사용.</p>
<h4 id="열거형-(Enum)">열거형 (Enum)</h4>
<blockquote>
  <p>JavaScript의 표준 자료형 집합과 사용하면 도움이 될만한 데이터 형은 enum입니다. C# 같은 언어처럼, enum은 값의 집합에 더 나은 이름을 붙여줄 수 있습니다.
  📌 출처 - <a href="https://typescript-kr.github.io/pages/basic-types.html#%ED%8A%9C%ED%94%8C-tuple">튜플 | 기본타입 | typescript GitBook</a></p>
</blockquote>
<pre><code class="language-typescript"><span class="hljs-comment">// javascript</span>
<span class="hljs-keyword">const</span> Color = {
  <span class="hljs-attr">Red</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">Blue</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">Green</span>: <span class="hljs-number">3</span>
}

<span class="hljs-comment">// typescript</span>
<span class="hljs-built_in">enum</span> Color {
  Red, Blue, Green
}</code></pre>
<p>선생님은 개인적으로 enum을 선호하지 않으신다고한다. enum이라고하는 데이터 타입은 코드이고 객체는 데이터일 수 있다.</p>
<p>enum은 코드이기 때문에, 만약 서버나 외부로부터 어떤 데이터를 가져오고 그 데이터를 객체로 표현해서 실제 UI에서 다루게 될 때. Color라고 하는 데이터를 가지고 왔다고 생각해보면, 그 데이터를 enum타입으로 변환시키기가 까다롭다. object는 그냥 변환해서 사용하면 되는데 enum은 데이터가 아니기 때문에 어려운 부분이 있다.</p>
<p>enum 타입의 데이터가 실제로 주고받는 용도의 데이터일 수 있는지 아닌지. 코드 내에서만 존재하면 되는지 판단해서 enum/object를 선택하면 된다.</p>
<p>(enum은 앞글자를 대문자로 쓰는 컨밴션이 있나보다.)</p>
<h4 id="Any">Any</h4>
<p>javascript 개발자가 typescript로 전환할때 점진적으로 할 수 있게 하기위단 수단 같은 것. 미끼 상품 같은 것 ㅎ</p>
<h4 id="Void">Void</h4>
<ul>
<li>자바스크립트에 존재는 하지만 잘 사용하지 않는 타입.</li>
<li>타입스크립트에서는 많이 사용함.</li>
<li>함수가 리턴값이 없을때 대표적으로 많이 사용함.</li>
</ul>
<h4 id="Never">Never</h4>
<blockquote>
  <p><code>never</code>&nbsp;타입은 절대 발생할 수 없는 타입을 나타냅니다. 예를 들어,&nbsp;<code>never</code>는 함수 표현식이나 화살표 함수 표현식에서 항상 오류를 발생시키거나 절대 반환하지 않는 반환 타입으로 쓰입니다. 변수 또한 타입 가드에 의해 아무 타입도 얻지 못하게 좁혀지면&nbsp;<code>never</code>&nbsp;타입을 얻게 될 수 있습니다.<br>
  <code>never</code>타입은 모든 타입에 할당 가능한 하위 타입입니다. 하지만 어떤 타입도&nbsp;<code>never</code>에 할당할 수 있거나, 하위 타입이 아닙니다.(<code>never</code>&nbsp;자신은 제외) 심지어&nbsp;<code>any</code>&nbsp;도&nbsp;<code>never</code>에 할당할 수 없습니다.<br>
  <code>never</code>를 반환하는 몇 가지 예제입니다:<br>
  📌 출처 - <a href="https://typescript-kr.github.io/pages/basic-types.html#%ED%8A%9C%ED%94%8C-tuple">Never | 기본타입 | typescript GitBook</a></p>
</blockquote>
<pre><code class="language-typescript"><span class="hljs-comment">// never를 반환하는 함수는 함수의 마지막에 도달할 수 없다.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">error</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">never</span> </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message);
}

<span class="hljs-comment">// 반환 타입이 never로 추론된다.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fail</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> error(<span class="hljs-string">"Something failed"</span>);
}

<span class="hljs-comment">// never를 반환하는 함수는 함수의 마지막에 도달할 수 없다.</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">infiniteLoop</span>(<span class="hljs-params"></span>): <span class="hljs-title">never</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    }
}</code></pre>
<h4 id="객체">객체</h4>
<ul>
<li>자바스크립트 코드 거의 대부분이 객체로 되어있다.</li>
<li>언어레벨에서 값으로 취급당하는것은 무엇이든 변수에 넣을 수 있다는 원칙이 있다.</li>
<li>자바스크립트/타입스크립트가 값이라고 하는 것을 데이터보다 훨씬 더 확장해놨다.</li>
<li>object도 값이라고 얘기를 하고 있는데, 객체 안에는 값도 있지만 코드도 들어있다.</li>
<li>이 특징을 가지고 할 수 있는 프로그래밍 방식이 엄청 많다.</li>
</ul>
<h3 id="6-3.-문법-타입">6-3. 문법-타입</h3>
<p>자바스크립트와 타입스크립트에서 타입을 다루는 방식의 차이에 대해서 구체적으로 설명.</p>
<h4 id="javascript">javascript</h4>
<ul>
<li>값을 넣는 순간 타입이 결정됨.</li>
<li>데이터를 변수에 들어가는 시점에 자유롭게 바꾼다는 매커니즘을 가지고 있는 언어.</li>
<li>타입을 느슨하게 관리함. 타입이 없는건 아님.</li>
<li>편리하지만 큰 불안정성이라고 알 수 있다.</li>
</ul>
<p>숫자를 인자로 받아야하는데 string을 넣었다면? 의도치 않는 에러가 나게됨.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAge</span>(<span class="hljs-params">age</span>) </span>{
 <span class="hljs-keyword">return</span> age + <span class="hljs-number">1</span>
}
<span class="hljs-built_in">console</span>.log(addAge(<span class="hljs-string">'30'</span>))</code></pre>
<p>이걸 예방하기 위해서는 age의 타입을 체크해야하고, 이 에러는 런타임에 나는 것이기 때문에 처리에 대해서도 고민해야함.</p>
<h4 id="typescript">typescript</h4>
<ul>
<li>타입을 지정하고 체크</li>
<li>런타임이 아니고 컴파일 타임에 에러를 잡아줌.</li>
<li>따라서 원천적으로 에러를 예방.</li>
<li>타입스크립트가 제공해주는 가장 큰 가치!</li>
</ul>
<h3 id="6-4.-문법-변수(&amp;상수)">6-4. 문법-변수(&amp;상수)</h3>
<p>변수 or 상수? 상수를 많이 쓰는 것을 추천. </p>
<p>변하는 값을 써야할때만 변수를 사용하라.</p>
<p>값 자체가 변해야된다는 것은 불안정성을 내포하고 있는 것.</p>
<h3 id="6-5.-문법-식(연산-또는-계산)">6-5. 문법-식(연산 또는 계산)</h3>
<ul>
<li>식 - 하나의 값으로 환원됨. (세미콜론 필요) 식=값</li>
<li>문 - 세미콜론 노필요. <code>if</code>,<code>for</code>문 세미콜론 찍어봤자 아무 의미 없음</li>
</ul>
<p>괄호로 감싸면 값이된다. → 여러 부분에서 세세하게 쓰이는 방법이니 기억하길바람.</p>
<h3 id="6-6.-문법-참조와-복사">6-6. 문법-참조와 복사</h3>
<p>참조와 복사는 간단하지만 중요한 메커니즘 중 하나.</p>
<p>원시값은 완전히 복사된다. <code>a=10</code>, <code>b=10</code>, <code>a=b</code> 로 해도 <code>a</code>와 <code>b</code>에 관계성이 생긴것은 아님.</p>
<p>그에 반해 객체는 항상 참조된다. 때문에 특정 함수 내부에서 값을 변경해버리면 그 이후에 작성된 로직이 값이 바뀌지 않았다는걸 전제로 작성되었을때 에러가 난다.</p>
<p>객체가 참조된다는것을 꼭 인지하고 코드를 짜야 안전한 코드를 작성할 수 있다.</p>
<h3 id="6-7.-문법-조건(분기)문">6-7. 문법-조건(분기)문</h3>
<p>if문의 코드가 한줄일때는 {}가 생략가능하지만. 추천하지 않는다. 코드라는것은 변화하고 2-3줄이 될수있다. </p>
<h3 id="6-8.-문법-반복문">6-8. 문법-반복문</h3>
<p>패스</p>
<h3 id="6-9.-문법-예외">6-9. 문법-예외</h3>
<p>이렇게만 작성하면 에러가 던져지면서 어플리케이션이 종료된다.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwError</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'앗 오류!'</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>{
  throwError()
}

init()</code></pre>
<p>에러를 던지기만 하는것이 아니라 받아주면 종료가 되지 않는데, 이때 <code>try catch</code>문을쓴다.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwError</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'앗 오류!'</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    throwError()
  } <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 모든 상황에서 실행됨.</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>)
  }
}

init()</code></pre>
<p>이렇게 작성하면 단순히 오류가 나는 것이 아니라, 오류를 처리한것이된다. 사용자에게 어떠한 피드백을 줄 수 있는 코드가 된 것.</p>
<p>위 예제는 <code>try</code> 문에 에러를 던지는 함수가 바로 들어가 있지만, 해당 함수에서 에러를 직접적으로 던지지 않아도 에러는 캐치할 수 있다.</p>
<p><code>catch</code>를 만날때까지 계속 위로 타고타고 에러가 올라간다. 그리고 마침내 잡히지 않으면 사이트가 종료됨.</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwError</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'앗 오류!'</span>)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yesYesYes</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSome</span>(<span class="hljs-params">isTrue</span>) </span>{
  <span class="hljs-keyword">if</span> (isTrue) {
    throwError()
  } <span class="hljs-keyword">else</span> {
    yesYesYes()
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    doSome(<span class="hljs-literal">true</span>)
  } <span class="hljs-keyword">catch</span>(e) {
    <span class="hljs-built_in">console</span>.log(e)
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 모든 상황에서 실행됨.</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'done'</span>)
  }
}

init()</code></pre>
<p><code>return</code> 값을 <code>false</code>로 해서 매번 <code>if</code>문 판정으로 오류 여부를 확인하는 것 보다 예외로 에러를 던져서 처리하면 효과적인 코드 구조를 만들 수 있다.</p>
<h3 id="6-10.-문법-인터페이스와-타입-별칭">6-10. 문법-인터페이스와 타입 별칭</h3>
<h4 id="타입알리아스">타입알리아스</h4>
<p>number는 숫자라는 의미만 있다. 좌표인지 갯수인지?</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> x: number = <span class="hljs-number">10</span></code></pre>
<p>이렇게 변수명에 의미를 부여하는 방법이 있겠지만</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> xPosition: number = <span class="hljs-number">10</span></code></pre>
<p>number라는 타입 자체에 의미를 부여하고싶다? 이럴때 쓰는 것이 타입별칭. 타입 알리아스라고 하는 것이다.</p>
<p>type을 앞에 붙이고 네이밍 컨밴션으로 앞글자에 대문자를 주로 사용한다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">type</span> Position = <span class="hljs-built_in">number</span>;

<span class="hljs-keyword">const</span> x: Position = <span class="hljs-number">10</span></code></pre>
<p>타입으로 기술된 것은 컴파일 타임에 이 값이 들어갔는지 아닌지 확인하는것이고, <code>enum</code> 타입은 실제 데이터로 컴파일 타임이 아니라 런타임에 값이 실제로 들어가는것. 특정 값으로 제한하는 기능은 유사하지만 이넘은 실제 데이터이고 타입은 컴파일 타임에 검사하는 용도로 사용됨.</p>
<h4 id="인터페이스">인터페이스</h4>
<ul>
<li>객체 규격 정의</li>
<li>타입알리아스와 인터페이스 동일하게 정의해놨다면, 모든 결과가 똑같다.</li>
<li>각각 언제 사용할지는 개발자가 정의하면된다.</li>
<li>인터페이스는 이름이 중복되면 내부 정의들을 합치는 특성이있고. 타입알리아스는 이름이 중복되면 에러를 뱉는다. 하지만 인터페이스를 중복되게 작성하는것은 지양하는것이 좋다.</li>
<li>인터페이스는 extends키워드로 인터페이스 확장 가능</li>
<li>타입알리아스는 인터섹션 기능으로 인터페이스 확장 가능</li>
</ul>
<p>이건 어떤 key이름이 어떤 데이터든 모두 숫자인 값만 가지고 있는 인터페이스이다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> OnlyNumberValueObject {
  [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>;
}</code></pre>
<p>함수 규격도 만들 수 있다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> IGetApi {
  (url: <span class="hljs-built_in">string</span>, search?: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;
}</code></pre>
<ul>
<li><p>타입알리아스로 함수 규격을 작성할때엔 화살표함수, brace 2가지 방법이 있다.</p></li>
<li><p>함수 규격을 함수에 사용할땐 항상 함수 정의문이 아닌 함수 표현식을 작성해야 한다.</p></li>
<li><p>인터페이스는 항상 퍼블릭만 다룬다. 따라서 인터페이스를 class에서 구현할때 인터페이스의 특정 값을 private으로 지정할 수 없다.</p>
<p>클래스의 규격과 생성자가 만들어내는 인스턴스의 규격이 미묘하게 다를때가 있을 수 있다. 그래서 인터페이스를 이용해서 생성자의 규격을 기술할 수 있다.</p></li>
</ul>
<pre><code class="language-typescript"><span class="hljs-keyword">interface</span> IRectConstructor {
  <span class="hljs-keyword">new</span> (x: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">width</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">height</span>: <span class="hljs-built_in">number</span>): IRect
}</code></pre>
<p>new 키워드를 사용해서 생성자 인스턴스를 만드는 것은 이런 인터페이스가 필요없다.  해당 클래스 자체가 설계도이기 때문. 클래스 자체는 설계도이기 때문에 타입으로 사용 가능.</p>
<p>하지만 생성자 인스턴스를 함수 안에서 만들게되면 스펙이 필요하다.</p>
<pre><code class="language-typescript"><span class="hljs-keyword">const</span> rect1 = <span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createDefaultRect</span>(<span class="hljs-params">cstor: IRectConstructor</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> cstor(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)
}</code></pre>
<p>기본적으로 타입알리아스, 인터페이스 어떤것을 쓰든 크게 상관은 없을듯 하다. 하지만 일관된 원칙을 세우고 코드를 작성하는게 좋다.</p>
<p>선생님 개인적인 스타일은 데이터를 표현할때는 타입알리아스를 쓰고.</p>
<p>메소드와 같은 구체적인 행위까지 포함된 객체를 표현할때는 인터페이스를 주로 쓴다. 클래스는 당연히 데이터와 행위를 포괄하고 있기 때문에 인터페이스가 자연스럽다고 생각한다.</p></div><div class="article-bottom" data-v-0cc18c81=""><p class="text-ps" data-v-0cc18c81=""><strong data-v-0cc18c81="">수정이 필요한 부분</strong> 혹은 <strong data-v-0cc18c81="">더 나은 방법</strong>을 알고계신가요? <br data-v-0cc18c81=""> 댓글로 알려주시면 저에게 큰 도움이 됩니다! 😊💜 </p><div class="vue-utterances" data-v-0cc18c81=""><div class="utterances" style="height: 269px;">
    <iframe class="utterances-frame" title="Comments" scrolling="no" src="https://utteranc.es/utterances.html?async=&amp;src=https%3A%2F%2Futteranc.es%2Fclient.js&amp;repo=yemsu%2Fyemsu.github.io&amp;issue-term=pathname&amp;theme=github-light&amp;crossorigin=anonymous&amp;url=http%3A%2F%2Flocalhost%3A8000%2Ffastcampus-javascript-typescript-essential-3&amp;origin=http%3A%2F%2Flocalhost%3A8000&amp;pathname=fastcampus-javascript-typescript-essential-3&amp;title=ENJOY+DEV&amp;description=&amp;og%3Atitle=&amp;session=" loading="lazy"></iframe>
  </div></div></div></article></div><footer data-v-183da9a0=""> copyright © <a href="https://github.com/yemsu" target="_blank" title="Github (새창)" data-v-183da9a0="">yemsu</a>. All right reserved. </footer></div><script src="/js/chunk-vendors.js"></script><script src="/js/app.js"></script><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none !important;" data-ad-status="unfilled"><div id="aswift_0_host" style="border: none; height: 0px; width: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;" tabindex="0" title="Advertisement" aria-label="Advertisement"><iframe id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0;width:undefinedpx;height:undefinedpx;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" src="https://googleads.g.doubleclick.net/pagead/ads?client=ca-pub-4052679554213032&amp;output=html&amp;adk=1812271804&amp;adf=3025194257&amp;lmt=1677935862&amp;plat=1%3A8%2C2%3A8%2C3%3A2162688%2C4%3A2162688%2C9%3A32776%2C16%3A8388608%2C17%3A32%2C24%3A32%2C25%3A32%2C30%3A1048576%2C32%3A32%2C41%3A32%2C42%3A32&amp;format=0x0&amp;url=http%3A%2F%2Flocalhost%3A8000%2Ffastcampus-javascript-typescript-essential-3&amp;ea=0&amp;pra=5&amp;wgl=1&amp;dt=1677935867572&amp;bpp=4&amp;bdt=1429&amp;idt=322&amp;shv=r20230301&amp;mjsv=m202302160101&amp;ptt=9&amp;saldr=aa&amp;abxe=1&amp;nras=1&amp;correlator=7607719529610&amp;frm=20&amp;pv=2&amp;ga_vid=1902918213.1677935868&amp;ga_sid=1677935868&amp;ga_hid=2089598602&amp;ga_fc=1&amp;u_tz=540&amp;u_his=2&amp;u_h=600&amp;u_w=800&amp;u_ah=600&amp;u_aw=800&amp;u_cd=24&amp;u_sd=1&amp;dmc=8&amp;adx=-12245933&amp;ady=-12245933&amp;biw=800&amp;bih=600&amp;scr_x=0&amp;scr_y=0&amp;eid=44777877%2C44759842%2C44759927%2C44759876%2C31071260%2C21065725&amp;oid=2&amp;pvsid=1429435740147854&amp;tmod=1690161382&amp;uas=0&amp;nvt=1&amp;fc=1920&amp;brdim=0%2C0%2C0%2C0%2C800%2C0%2C800%2C600%2C800%2C600&amp;vis=1&amp;rsz=%7C%7Cs%7C&amp;abl=NS&amp;fu=33792&amp;bc=31&amp;ifi=1&amp;uci=a!1&amp;fsb=1&amp;dtd=401" data-google-container-id="a!1" data-load-complete="true"></iframe></div></ins></body><iframe id="google_esf" name="google_esf" src="https://googleads.g.doubleclick.net/pagead/html/r20230301/r20190131/zrt_lookup.html" style="display: none;"></iframe></html>